PART1:

در قسمت اول انجام آزمایش از روش TDD برای کد نویسی استفاده شده است بدین صورت که تست مربوط به هر فیچر نوشته شده مشکلات کامپایل آن رفع شده و سپس تست رد میشود و کد مربوطه نوشته شده و در آخر نیز تست پاس خواهد شد.

در شکل های زیر کدزدن بدین روش را میتوانید ببینید.

ابتدا فیچر مربوط به مستطیل را میبینید

![TDD](./ScreenShots/CompileError1.png)


![TDD2](./ScreenShots/removing%20compile%20bugs.png)

![TDD3](./ScreenShots/MakeTestPass.png)


همچنین تست دیگر برای آن که وقتی که طول مستطیل نامعتبر است



![TDD4](./ScreenShots/AddAnotherTest.png)

![TDD6](./ScreenShots/failedTest2.png)

![TDD6](./ScreenShots/MakeTestPass2.png)



مابقی فیچر ها مثل مربع و محاسبه مساحت آن نیز با استفاده از روش TDD نوشته شده است.

در این قسمت برای رعایت اصل Liskov از اصول solid هر کدام از اشکال مربوط به مربع و مستطیل یک کلاس جداگانه بودند که از یکدیگر ارث بری نمیکردند و صرفا کلاس های مدل بودند.

برای رعایت SRP نیز محاسبه مساحت از کلاس های مربع و مستطیل حذف شد تا این کلاس ها صرفا یک دارنده برای مشخصات اصلی هر شکل باشد و برای چک کردن معتبر بودن طول ها یک استثنا نیز اضافه شد.

برای رعایت DIP نیز این مدل در نظر گرفته شد که یک interface جدا که جنریک است برای محاسبه مساحت در نظر گرفته شد. که این interface برای اشکال محتلف پیاده سازی مختلف دارد و در کلاس های دیگر میتواند inject شود.

این interface دو پیاده سازی یکی برای محاسبه مساحت مربع و دیگری برای محاسبه مساحت مستطیل دارد که هر دوی آن ها در کلاس های تست مربوطه inject شده اند.

از این به بعد اگر شکل جدید اضافه شود در کلاس های مدل صرفا مشخصات آن شکل اضافه شده و یک پیاده سازی جدید از interface مربوط به محاسبه مساحت انجام خواهد شد.

کلاس های مدل نیز درگیر محاسبه مساحت و ... نیستند. پس بنابراین علاوه بر اصل های فوق OCP نیز رعایت شده است زیرا تا حد امکان از تغییرات جلوگیری میشود و صرفا فیچر جدید اضافه میشود.





Part2:

1 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.
 
single responsibility:

این اصل بیان میکند که هر کلاسی و یا هر ماژولی وظیفه انجام یک کار را دارد
 
و باید فقط به یک دلیل در آینده تغییر کند. این اصل بیان میکند که کلاس ما نباید چندین کار متفاوت را انجام دهد

open closed principle : 

این اصل بیان می کند که نرم افزار ما باید برای افزودن فیچر ها و نیازمندی های جدید آماده و باز باشد

ولی برای تغییرات تا جای ممکن بسته باشد. مفهوم آن بدین صورت است که وقتی میخواهیم فیچر یا نیازمندی جدیدی پیاده سازی کنیم

باید بتوانیم آن را به سادگی اضافه کنیم بدون آن که در تابع ها و کلاس های قبلی تغییرات بدهیم. صرفا باید کلاس ها و متد های جدید اضافه شود.

Liskov Substitution:

این اصل بیان میکند که کلاس های پدر و فرزند باید قابل جایگذاری باشند و بتوان کلاس های فرزند را جای پدرها گذاشت بدئن آن که در منطق تابع های به ارث رسیده و پیاده سازی 

شده تغییری ایجاد شود.

Interface Segregation:

این اصل بیان میکند که interface ها برای پیاده سازی توابع شان باید به یکدیگر مربوط باشد و نه این که یک interface بزرگ داشته باشیم که انواع

توابع مختلف که کار های مختلف را میکنند داشته باشد. باید توابع مختلف که کار های مربوط به همدیگر را میکنند جدا کنیم و در interface های مختلف قرار دهیم

تا در این صورت به مشکلاتی نظیر خالی بودن پیاده سازی در کلاس های پیاده سازی این interface ها دچار نشویم

Dependency inversion principle:

این اصل بیان میکند که کلاس های سطح بالا نباید به کلاس های سطح پایین وابسته باشند بلکه باید به abstraction آن ها وابسته باشند.

وابتسگی بدین معناست که یک کلاس در یک کلاس دیگر استفاده شده باشد. برای آن که این اصل رعایت شود معمولا کلاسی که درون کلاس دیگر استفاده میشود را به صورت concrete استفاده نمیکنند

بلکه در اغلب مواقع یک interface از آن بیرون میکشند و interface را در کلاس سطحل بالا inject میکنند.

>>>>>>>>>>>>>>>>>>>>>>>>2:
اصول solid در طراحی و پیاده ساازی استفاده میشوند زیرا مربوط به نحوه کد نوشتن و نحوه جدا کردن کلاس ها و یا حتی سرویس های مختلف را نشان میدهند.


>>>>>>>>>>>>>>>>>>>>>>>>3:
این دو مورد با یکدیگر تناقضی ندارند. زیرا نوشتن تست در کل باعث میشود که ماژول های مختلف نرم افزار ما تست شده باشند و خیال ما از این بابت آسوده باشد
 
همچنین باعث میشود که اگر کد ما refactor شود و ساختارش بهبود یابد اطمینان حاصل کنیم که در پیاده سازی منطق و درستی منطق خللی ایجاد نشده است.

در کل کد بدون تست بدترین کدی است که وجود دارد. همچنین نوشتن تست باعث میشود که کد ما خوانا تر شود زیرا فر جدید در مواجهه با کد میتواند تست ها را بخواند و از عملکرد کلی برنامه متوجه شود که برنامه چه کار میکند.

اما این که اول تست را بنویسیم و سپس کد بزنیم و یا اول کد بزنیم و سپس تست را بنویسیم یک فرق کوچک دارد آن هم اینست که اگر اول کد بزنیم و سپس تست بنویسیم در هنگام نوشتن تست

ممکن است مجبور شویم کدمان را refactor کنیم یعنی هم تست بنویسیم و هم کد را تغییر دهیم.

ولی در روش TDD که اول تست مینویسیم تمرکز ما بر روی یکیست یا داریم تست مینویسیم و یا داریم کد میزنیم و ریفکتور میکنیم.

>>>>>>>>>>>>>>>>>>>>>>>>>>4:

با توجه به پیاده سازی صورت گرفته صرفا تابع های setter از بین میرفتند و در طراحی کلی تغییری ایجاد نمیشد زیرا اصول شی گرا رعایت شده و هر تغییری کمترین هزینه را برای ما خواهد داشت.